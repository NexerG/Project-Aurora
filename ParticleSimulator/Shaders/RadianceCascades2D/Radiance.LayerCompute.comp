#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16) in;

struct PD
{
	int cascade;
	int rayCount;
	int rayLength;
	int rayOffset;
	ivec2 probeCount;
	ivec2 probeDist;
	vec2 offset;
};

layout(binding = 0, scalar) buffer ProbeData{
    PD data[];
} probes;

layout(set = 0, binding = 1, rgba8) uniform image2D layeredColor[];
layout(set = 0, binding = 2, rgba8) uniform image2D layeredLight[];
layout(set = 0, binding = 3, rgba8) uniform image2D layeredFinal[];
layout(set = 0, binding = 4, rgba8) uniform image2D probeTexels[];

layout(push_constant) uniform PC{
	int currentLayer;
} pc;

vec4 Luminosity(ivec2 pos)
{
    vec4 luminosity = vec4(0.0f);

    int cascadeIndex = 0;
    PD pd = probes.data[cascadeIndex];

    while(pd.rayCount > 0)
    {
        vec2 pureIndex = (vec2(pos) / vec2(pd.probeDist)) - pd.offset;

        ivec2 topLeft = ivec2(floor(pureIndex)); //top left
        ivec2 topRight = topLeft + ivec2(1, 0);
        ivec2 botRight = topLeft + ivec2(1, 1);
        ivec2 botLeft = topLeft + ivec2(0, 1);

        ivec2 probeIndex[4] = ivec2[4](
            topLeft, botLeft, topRight, botRight
        );

        vec2 uv = pureIndex - topLeft;

        float w1 = (1.0f - uv.x) * (1.0f - uv.y);
        float w2 = uv.x * (1.0f - uv.y);
        float w3 = (1.0f - uv.x) * uv.y;
        float w4 = uv.x * uv.y;

        float weights[4] = float[4](
            w1, w3, w2, w4);

        for(int i=0; i < 4; i++)
        {
            ivec2 texel = ivec2(probeIndex[i] * sqrt(pd.rayCount));

            int levels = int(pow(2, pd.cascade + 1));
            vec4 cl = vec4(0.0f);
            for(int vertical = 0; vertical < levels; vertical++)
            {
                for(int horizontal = 0; horizontal < levels; horizontal++)
                {
                    cl += imageLoad(probeTexels[cascadeIndex], texel + ivec2(horizontal, vertical));
                }
            }
            luminosity += (cl / pd.rayCount) * weights[i];
        }
        cascadeIndex++;
        pd = probes.data[cascadeIndex];
    }

    return luminosity;
}


void main()
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);    //current pixel pos
    vec4 luminosity = Luminosity(pos);              // calc the luminosity of the pixel

    vec4 pixel = imageLoad(layeredColor[pc.currentLayer], pos);
    //vec4 color = vec4(vec3(pixel), 1.0f) * luminosity;
    vec4 color = vec4(vec3(pixel), 1.0f) * luminosity;

    imageStore(layeredFinal[pc.currentLayer], pos, color);
    return;
}